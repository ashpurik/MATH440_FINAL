void solve(int* array, int grid_size) {
  cout << "Iteration: " << iterate << endl;
  int location = loc[0]*sqrt(grid_size) + loc[1];
  //cout << "Location : " << location << endl;
  int distances[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};

  if (iterate == 100) {
    return;
  }

  if (manhattanDistances(array, grid_size) == 0) {
    return;
  } else {
    if(checkLeft(location, sqrt(grid_size))) {
      //cout << "in left" << endl;
      swap(array, location, location-1);
      distances[0] = manhattanDistances(array, grid_size);
      swap(array, location, location-1);
    }
    if(checkRight(location, sqrt(grid_size))) {
      //cout << "in right" << endl;
      swap(array, location, location+1);
      distances[1] = manhattanDistances(array, grid_size);
      swap(array, location, location+1);
    }
    if(checkUp(location, sqrt(grid_size))) {
      //cout << "in up" << endl;
      swap(array, location-1, location);
      distances[2] = manhattanDistances(array, grid_size);
      swap(array, location-1, location);
    }
    if(checkDown(location, sqrt(grid_size))) {
      //cout << "in down" << endl;
      swap(array, location+1, location);
      distances[3] = manhattanDistances(array, grid_size);
      swap(array, location+1, location);
    }

    printArray(distances, 4);
    cout << endl;
    //cout << "Previous: " << prev << endl;

    int smallestPos = findSmallest(distances);
    switch (smallestPos) {
      case 0: 
        //cout << "swapped Left\n" << endl;
        swap(array, location, location-1);
        loc[1] = (location-1) % int(sqrt(grid_size));
        prev = 0;
        break;
      case 1:
        //cout << "swapped Right\n" << endl;
        swap(array, location, location+1);
        loc[1] = (location+1) % int(sqrt(grid_size));
        prev = 1;
        break;
      case 2:
        //cout << "swapped Up\n" << endl;
        swap(array, location-sqrt(grid_size), location);
        loc[0] = (location-sqrt(grid_size)) / sqrt(grid_size);
        //cout << "Moving to " << location-1 << "from " << location << endl;
        prev = 2;
        break;
      case 3:
        //cout << "swapped down\n" << endl;
        swap(array, location+sqrt(grid_size), location);
        loc[0] = (location+sqrt(grid_size)) / sqrt(grid_size);
        //cout << "Moving to " << location+1 << " from " << location << endl;
        prev = 3;
        break;
    }

   //int** test = convertArraytoMatrix(array, sqrt(grid_size));
   //printMatrix(test, sqrt(grid_size), sqrt(grid_size));
    //cout << endl;
    //prev = location;
    iterate++;
    solve(array, grid_size);
  }
}

int findSmallest(int* array) {
  int smallest = INT_MAX;
  int index = 0;
  for (int i=0; i<4; i++) {
    if (array[i] < smallest) {
      smallest = array[i];
      index = i;
    }
  }
  return index;
}

void swap(int* array, int loc1, int loc2) {
  int temp = array[loc2];
  array[loc2] = array[loc1];
  array[loc1] = temp;
}

bool checkLeft(int position, int n) {
  //cout << "Left check: " << position << ". Previous: " << prev << endl;
  if (position % n == 0 || prev == 1) {
    return false;
  } else {
    return true;
  }
}

bool checkRight(int position, int n) {
  //cout << "Right check: " << position << ". Previous: " << prev << endl;
  if (position % n == (n-1) || prev == 0) {
    return false;
  } else {
    return true;
  }
}

bool checkUp(int position, int n) {
  //cout << "Up check: " << position << ". Previous: " << prev << endl;
  if (position / n == 0 || prev == 3) {
    return false;
  } else {
    return true;
  }
}

bool checkDown(int position, int n) {
  //cout << "Down check: " << position << ". Previous: " << prev << endl;
  if (position / n == (n-1) || prev == 2) {
    return false;
  } else {
    return true;
  }
}
